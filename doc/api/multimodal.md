# MultiModal

`from multimodal_challenge.multimodal import MultiModal`

Search for a dropped object in a room using the [Magnebot API](https://github.com/alters-mit/magnebot) and pre-calculated audio that was generated by a physics simulation of the falling object.

```python
from multimodal_challenge.multimodal import MultiModal

m = MultiModal()
m.init_scene(scene="mm_kitchen_1a", layout=0, trial=57)
```

Each combination of `init_scene()` parameters loads a trial. Each trial was generated by [`dataset.py`](../dataset/dataset.md).

Per trial, the scene is initialized to be exactly as it was when the object stopped moving (after it fell).
Each trial has audio data that was generated as the object collided with other objects and the walls and floors.

Using its camera and the audio data, the Magnebot must find the dropped object.

## Environment variables

#### 1. `MULTIMODAL_ASSET_BUNDLES`

**The root directory to download scenes and asset bundles from.** Default value: `"https://tdw-public.s3.amazonaws.com"`

Every scene (room environment) and model (furniture, cabinets, cups, etc.) is stored in TDW as an [asset bundle](https://docs.unity3d.com/Manual/AssetBundlesIntro.html). These asset bundles are downloaded at runtime from a remote S3 server, but it is possible to download them *before* run time and load them locally. **If your Internet connection will make it difficult/slow/impossible to download large US-based files at runtime, we strongly suggest you download them locally.** To do this:

1. `cd path/to/multimodal_challenge`
2. `python3 download.py --dst [DST]`. The `--dst` argument sets the root download directory. Example: `python3 download.py --dst /home/mm_asset_bundles`.

#### 2. `MULTIMODAL_DATASET`

**The directory where the Trial files will be saved.** Default value: `"D:/multimodal_challenge"`

#### How to set the environment variables

- Replace `[asset_bundles]` and `[dataset]` with the actual paths. For example: `export MULTIMODAL_ASSET_BUNDLES=/home/mm_asset_bundles`.
- Replace `my_controller.py` with the name of your controller script.

| Platform             | Command                                                      |
| -------------------- | ------------------------------------------------------------ |
| OS X or Linux        | `export MULTIMODAL_ASSET_BUNDLES=[asset_bundles] && export MULTIMODAL_DATASET=[dataset] && python3 my_controller.py` |
| Windows (cmd)        | `set MULTIMODAL_ASSET_BUNDLES=[asset_bundles] && set MULTIMODAL_DATASET=[dataset] && py -3 my_controller.py` |
| Windows (powershell) | `$env:MULTIMODAL_ASSET_BUNDLES="[asset_bundles]" ; $env:MULTIMODAL_DATASET="[dataset]" ; py -3 my_controller.py` |

## Overview of API

- [Environment variables](#environment-variables)
- [Class Variables](#class-variables)
- [Frames](#frames)
- [Parameter types](#parameter-types)
- [Fields](#fields)
- [Functions](#functions)

| Function | Description |
| --- | --- |
| [\_\_init\_\_](#\_\_init\_\_) | |
| [init_scene](#init_scene) | Initialize a scene and a furniture layout, including the target object after it has fallen. |
| [reach_for](#reach_for) | Reach for a target position. |
| [grasp](#grasp) | Try to grasp the target object with the arm. |
| [drop](#drop) | Drop an object held by a magnet. |
| [reset_arm](#reset_arm) | Reset an arm to its neutral position. |
| [set_torso](#set_torso) | Slide the Magnebot's torso up or down. |
| [rotate_camera](#rotate_camera) | Rotate the Magnebot's camera by the (roll, pitch, yaw) axes. |
| [reset_camera](#reset_camera) | Reset the rotation of the Magnebot's camera to its default angles. |
| [get_occupancy_position](#get_occupancy_position) | Converts the position `(i, j)` in the occupancy map to `(x, z)` worldspace coordinates. |
| [get_visible_objects](#get_visible_objects) | Get all objects visible to the Magnebot in `self.state` using the id (segmentation color) image. |
| [end](#end) | End the simulation. |

***

## Class Variables

| Variable | Type | Description |
| --- | --- | --- |
| `SCENE_LAYOUTS` | Dict[str, int] | A dictionary of each scene name and the number of layouts per scene. Use this to set the `scene` and `layout` parameters of `init_scene()`. |
| `TRIALS_PER_SCENE_LAYOUT` | int | The number of trials per scene_layout combination. Use this to set the `trial` parameter of `init_scene()`: |
| `TORSO_LIMITS` | Tuple[float, float] | The lower and upper limits of the torso's position from the floor (y=0), assuming that the Magnebot is level. |
| `CAMERA_RPY_CONSTRAINTS` | List[float] | The camera roll, pitch, yaw constraints in degrees. |

***

## Frames

Every action advances the simulation by 1 or more _simulation frames_. This occurs every time the `communicate()` function is called (which all actions call internally).

Every simulation frame advances the simulation by contains `1 + n` _physics frames_. `n` is defined in the `skip_frames` parameter of the Magnebot constructor. This greatly increases the speed of the simulation.

Unless otherwise stated, "frame" in the Magnebot API documentation always refers to a simulation frame rather than a physics frame.

***

## Parameter types

The types `Dict`, `Union`, and `List` are in the [`typing` module](https://docs.python.org/3/library/typing.html).

#### Dict[str, float]

Parameters of type `Dict[str, float]` are Vector3 dictionaries formatted like this:

```json
{"x": -0.2, "y": 0.21, "z": 0.385}
```

`y` is the up direction.

To convert from or to a numpy array:

#### Union[Dict[str, float], int]]

Parameters of type `Union[Dict[str, float], int]]` can be either a Vector3 or an integer (an object ID).

#### Arm

All parameters of type `Arm` require you to import the [Arm enum class](https://github.com/alters-mit/magnebot/blob/main/doc/api/arm.md):

***

## Fields

- `audio` The pre-recorded audio generated by the target object falling as a .wav file.

- `target_object_id` The ID of the target object (the object that fell).

- `state` [Dynamic data for all of the most recent frame after doing an action.](https://github.com/alters-mit/magnebot/blob/main/doc/api/scene_state.md) This includes image data, physics metadata, etc.       

- `auto_save_images` If True, automatically save images to `images_directory` at the end of every action.

- `images_directory` The output directory for images if `auto_save_images == True`. This is a [`Path` object from `pathlib`](https://docs.python.org/3/library/pathlib.html).

- `camera_rpy` The current (roll, pitch, yaw) angles of the Magnebot's camera in degrees as a numpy array. This is handled outside of `self.state` because it isn't calculated using output data from the build. See: `Magnebot.CAMERA_RPY_CONSTRAINTS` and `self.rotate_camera()`

- `colliding_objects` A list of objects that the Magnebot is currently colliding with.

- `colliding_with_wall` If True, the Magnebot is currently colliding with a wall.

- `objects_static` [Data for all objects in the scene that that doesn't change between frames, such as object IDs, mass, etc.](https://github.com/alters-mit/magnebot/blob/main/doc/api/object_static.md) Key = the ID of the object..

- `magnebot_static` [Data for the Magnebot that doesn't change between frames.](https://github.com/alters-mit/magnebot/blob/main/doc/api/magnebot_static.md)

- `occupancy_map` A numpy array of the occupancy map. This is None until you call `init_scene()`.

Shape = `(1, width, length)` where `width` and `length` are the number of cells in the grid. Each grid cell has a radius of 0.245. To convert from occupancy map `(x, y)` coordinates to worldspace `(x, z)` coordinates, see: `get_occupancy_position()`.

Each element is an integer describing the occupancy at that position.

| Value | Meaning |
| --- | --- |
| -1 | This position is outside of the scene. |
| 0 | Unoccupied and navigable; the Magnebot can go here. |
| 1 | This position is occupied by an object(s) or a wall. |
| 2 | This position is free but not navigable (usually because there are objects in the way. |

The occupancy map is static, meaning that it won't update when objects are moved.

Note that it is possible for the Magnebot to go to positions that aren't "free". The Magnebot's base is a rectangle that is longer on the sides than the front and back. The occupancy grid cell size is defined by the longer axis, so it is possible for the Magnebot to move forward and squeeze into a smaller space. The Magnebot can also push, lift, or otherwise move objects out of its way.

***

## Functions

#### \_\_init\_\_

**`MultiModal()`**

**`MultiModal(port=1071, screen_width=256, screen_height=256)`**

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| port |  int  | 1071 | The socket port. [Read this](https://github.com/threedworld-mit/tdw/blob/master/Documentation/getting_started.md#command-line-arguments) for more information. |
| screen_width |  int  | 256 | The width of the screen in pixels. |
| screen_height |  int  | 256 | The height of the screen in pixels. |

***

### Scene Setup

These functions should be sent at the start of the simulation.

#### init_scene

**`self.init_scene(scene, layout)`**

**`self.init_scene(scene, layout, trial=None)`**

**Always call this function before starting a new trial.** Initialize a scene and a furniture layout, including the target object after it has fallen.
Load the corresponding audio that was generated by the fall (`self.fall`) and position the Magnebot in the same spot as where it was when the object fell.

- For a dictionary of valid scene names and layout indices, see: `MultiModal.SCENE_LAYOUTS`.
- For the total number of trials per scene_layout, see: `MultiModal.TRIALS_PER_SCENE_LAYOUT`
- [These are images of every scene_layout combination](https://github.com/alters-mit/multimodal_challenge/tree/main/doc/images/scene_layouts)

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| scene |  str |  | The name of the scene. |
| layout |  int |  | The layout index. |
| trial |  int  | None | The trial number. |

_Returns:_  An `ActionStatus` (always success).

***

### Arm Articulation

These functions move and bend the joints of the Magnebots's arms.

During an arm articulation action, the Magnebot is always "immovable", meaning that its wheels are locked and it isn't possible for its root object to move or rotate.

For more information regarding how arm articulation works, [read this](https://github.com/alters-mit/magnebot/blob/main/doc/api/../arm_articulation.md).

#### reach_for

**`self.reach_for(target, arm)`**

**`self.reach_for(target, arm, absolute=True, arrived_at=0.125, target_orientation=TargetOrientation.auto, orientation_mode=OrientationMode.auto)`**

Reach for a target position.

The action ends when the arm stops moving. The arm might stop moving if it succeeded at finishing the motion, in which case the action is successful. Or, the arms might stop moving because the motion is impossible, there's an obstacle in the way, if the arm is holding something heavy, and so on.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `cannot_reach`
- `failed_to_reach`

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| target |  Dict[str, float] |  | The target position for the magnet at the arm to reach. |
| arm |  Arm |  | The arm that will reach for the target. |
| absolute |  bool  | True | If True, `target` is in absolute world coordinates. If `False`, `target` is relative to the position and rotation of the Magnebot. |
| arrived_at |  float  | 0.125 | If the magnet is this distance or less from `target`, then the action is successful. |
| target_orientation |  TargetOrientation  | TargetOrientation.auto | [The target orientation of the IK solution.](https://github.com/alters-mit/magnebot/blob/main/doc/api/../arm_articulation.md) |
| orientation_mode |  OrientationMode  | OrientationMode.auto | [The orientation mode of the IK solution.](https://github.com/alters-mit/magnebot/blob/main/doc/api/../arm_articulation.md) |

_Returns:_  An `ActionStatus` indicating if the magnet at the end of the `arm` is at the `target` and if not, why.

#### grasp

**`self.grasp(target, arm)`**

**`self.grasp(target, arm, target_orientation=TargetOrientation.auto, orientation_mode=OrientationMode.auto)`**

Try to grasp the target object with the arm. The Magnebot will reach for the nearest position on the object.

If the magnet grasps the object, the arm will stop moving and the action is successful.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `cannot_reach`
- `failed_to_grasp`

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| target |  int |  | The ID of the target object. |
| arm |  Arm |  | The arm of the magnet that will try to grasp the object. |
| target_orientation |  TargetOrientation  | TargetOrientation.auto | [The target orientation of the IK solution.](https://github.com/alters-mit/magnebot/blob/main/doc/api/../arm_articulation.md) |
| orientation_mode |  OrientationMode  | OrientationMode.auto | [The orientation mode of the IK solution.](https://github.com/alters-mit/magnebot/blob/main/doc/api/../arm_articulation.md) |

_Returns:_  An `ActionStatus` indicating if the magnet at the end of the `arm` is holding the `target` and if not, why.

#### drop

**`self.drop(target, arm)`**

**`self.drop(target, arm, wait_for_objects=True)`**

Drop an object held by a magnet.

See [`SceneState.held`](https://github.com/alters-mit/magnebot/blob/main/doc/api/scene_state.md) for a dictionary of held objects.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `not_holding`

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| target |  int |  | The ID of the object currently held by the magnet. |
| arm |  Arm |  | The arm of the magnet holding the object. |
| wait_for_objects |  bool  | True | If True, the action will continue until the objects have finished falling. If False, the action advances the simulation by exactly 1 frame. |

_Returns:_  An `ActionStatus` indicating if the magnet at the end of the `arm` dropped the `target`.

#### reset_arm

**`self.reset_arm(arm)`**

**`self.reset_arm(arm, reset_torso=True)`**

Reset an arm to its neutral position.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `failed_to_bend`

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| arm |  Arm |  | The arm that will be reset. |
| reset_torso |  bool  | True | If True, rotate and slide the torso to its neutral rotation and height. |

_Returns:_  An `ActionStatus` indicating if the arm reset and if not, why.

***

***

### Torso

These functions adjust the Magnebot's torso.

While adjusting the torso, the Magnebot is always "immovable", meaning that its wheels are locked and it isn't possible for its root object to move or rotate.

#### set_torso

**`self.set_torso(position)`**

Slide the Magnebot's torso up or down.

The torso's position will be reset the next time the Magnebot moves or turns.

Possible return values:

- `success`
- `failed_to_bend` (If the torso failed to reach the target position)

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| position |  float |  | The target vertical position of the torso. This is clamped to be within the torso limits (see: `MultiModal.TORSO_LIMITS`). |

_Returns:_  An `ActionStatus` indicating if the torso reached the target position.

***

### Camera

_These commands rotate the Magnebot's camera or add additional camera to the scene. They advance the simulation by exactly 1 frame._

#### rotate_camera

**`self.rotate_camera()`**

**`self.rotate_camera(roll=0, pitch=0, yaw=0)`**

Rotate the Magnebot's camera by the (roll, pitch, yaw) axes.

Each axis of rotation is constrained (see `Magnebot.CAMERA_RPY_CONSTRAINTS`).

| Axis | Minimum | Maximum |
| --- | --- | --- |
| roll | -55 | 55 |
| pitch | -70 | 70 |
| yaw | -85 | 85 |

See `self.camera_rpy` for the current (roll, pitch, yaw) angles of the camera.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `clamped_camera_rotation`

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| roll |  float  | 0 | The roll angle in degrees. |
| pitch |  float  | 0 | The pitch angle in degrees. |
| yaw |  float  | 0 | The yaw angle in degrees. |

_Returns:_  An `ActionStatus` indicating if the camera rotated fully or if the rotation was clamped..

#### reset_camera

**`self.reset_camera()`**

Reset the rotation of the Magnebot's camera to its default angles.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`

_Returns:_  An `ActionStatus` (always `success`).

### Misc.

_These are utility functions that won't advance the simulation by any frames._

#### get_occupancy_position

**`self.get_occupancy_position(i, j)`**

Converts the position `(i, j)` in the occupancy map to `(x, z)` worldspace coordinates.

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| i |  int |  | The i coordinate in the occupancy map. |
| j |  int |  | The j coordinate in the occupancy map. |

_Returns:_  Tuple: (x coordinate; z coordinate) of the corresponding worldspace position.

#### get_visible_objects

**`self.get_visible_objects()`**

Get all objects visible to the Magnebot in `self.state` using the id (segmentation color) image.

_Returns:_  A list of IDs of visible objects.

#### end

**`self.end()`**

End the simulation. Terminate the build process.

***

