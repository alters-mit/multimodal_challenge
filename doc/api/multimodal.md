# MultiModal

`from multimodal_challenge.multimodal import MultiModal`

Search for a dropped object in a room using the [Magnebot API](https://github.com/alters-mit/magnebot) and pre-calculated audio that was generated by a physics simulation of the falling object.

```python
from multimodal_challenge.multimodal import MultiModal

m = MultiModal()
m.init_scene(scene="mm_kitchen_1a", layout=0, trial=57)
```

Each combination of `init_scene()` parameters loads a trial. Each trial was generated by [`dataset.py`](../dataset/dataset.md).

Per trial, the scene is initialized to be exactly as it was when the object stopped moving (after it fell).
Each trial has audio data that was generated as the object collided with other objects and the walls and floors.

Using its camera and the audio data, the Magnebot must find the dropped object.

- [Class variables](#class-variables)
- [Frames](#frames)
- [Parameter types](#parameter-types)
- [Fields](#fields)
- [Functions](#functions)
  - [\_\_init\_\_](#\_\_init\_\_)
  - [init_scene](#init_scene)
  - [turn_by](#turn_by)
  - [turn_to](#turn_to)
  - [move_by](#move_by)
  - [move_to](#move_to)
  - [set_torso](#set_torso)
  - [guess](#guess)
  - [rotate_camera](#rotate_camera)
  - [reset_camera](#reset_camera)
  - [get_occupancy_position](#get_occupancy_position)
  - [get_visible_objects](#get_visible_objects)
  - [end](#end)


***

## Class Variables
| Variable | Type | Description |
| --- | --- | --- |
| `SCENE_LAYOUTS` | Dict[str, int] | A dictionary of each scene name and the number of layouts per scene. Use this to set the `scene` and `layout` parameters of `init_scene()`. |
| `TRIALS_PER_SCENE_LAYOUT` | int | The number of trials per scene_layout combination. Use this to set the `trial` parameter of `init_scene()`: |
| `TORSO_LIMITS` | Tuple[float, float] | The lower and upper limits of the torso's position from the floor (y=0), assuming that the Magnebot is level. |


| Variable | Type | Description |
| --- | --- | --- |
| `CAMERA_RPY_CONSTRAINTS` | List[float] | The camera roll, pitch, yaw constraints in degrees. |

***

## Frames

Every action advances the simulation by 1 or more _simulation frames_. This occurs every time the `communicate()` function is called (which all actions call internally).

Every simulation frame advances the simulation by contains `1 + n` _physics frames_. `n` is defined in the `skip_frames` parameter of the Magnebot constructor. This greatly increases the speed of the simulation.

Unless otherwise stated, "frame" in the Magnebot API documentation always refers to a simulation frame rather than a physics frame.

***

## Parameter types

The types `Dict`, `Union`, and `List` are in the [`typing` module](https://docs.python.org/3/library/typing.html).

#### Dict[str, float]

Parameters of type `Dict[str, float]` are Vector3 dictionaries formatted like this:

```json
{"x": -0.2, "y": 0.21, "z": 0.385}
```

`y` is the up direction.

To convert from or to a numpy array:


#### Union[Dict[str, float], int]]

Parameters of type `Union[Dict[str, float], int]]` can be either a Vector3 or an integer (an object ID).

#### Arm

All parameters of type `Arm` require you to import the [Arm enum class](https://github.com/alters-mit/magnebot/blob/main/doc/api/arm.md):


***


## Fields

- `audio` The pre-recorded audio generated by the target object falling as a .wav file.

- `target_object_id` The ID of the target object (the object that fell).


- `state` [Dynamic data for all of the most recent frame after doing an action.](https://github.com/alters-mit/magnebot/blob/main/doc/api/scene_state.md) This includes image data, physics metadata, etc.       


- `auto_save_images` If True, automatically save images to `images_directory` at the end of every action.

- `images_directory` The output directory for images if `auto_save_images == True`. This is a [`Path` object from `pathlib`](https://docs.python.org/3/library/pathlib.html).

- `camera_rpy` The current (roll, pitch, yaw) angles of the Magnebot's camera in degrees as a numpy array. This is handled outside of `self.state` because it isn't calculated using output data from the build. See: `Magnebot.CAMERA_RPY_CONSTRAINTS` and `self.rotate_camera()`

- `colliding_objects` A list of objects that the Magnebot is currently colliding with.

- `colliding_with_wall` If True, the Magnebot is currently colliding with a wall.

- `objects_static` [Data for all objects in the scene that that doesn't change between frames, such as object IDs, mass, etc.](https://github.com/alters-mit/magnebot/blob/main/doc/api/object_static.md) Key = the ID of the object..


- `magnebot_static` [Data for the Magnebot that doesn't change between frames.](https://github.com/alters-mit/magnebot/blob/main/doc/api/magnebot_static.md)


- `occupancy_map` A numpy array of the occupancy map. This is None until you call `init_scene()`.

Shape = `(1, width, length)` where `width` and `length` are the number of cells in the grid. Each grid cell has a radius of 0.245. To convert from occupancy map `(x, y)` coordinates to worldspace `(x, z)` coordinates, see: `get_occupancy_position()`.

Each element is an integer describing the occupancy at that position.

| Value | Meaning |
| --- | --- |
| -1 | This position is outside of the scene. |
| 0 | Unoccupied and navigable; the Magnebot can go here. |
| 1 | This position is occupied by an object(s) or a wall. |
| 2 | This position is free but not navigable (usually because there are objects in the way. |


The occupancy map is static, meaning that it won't update when objects are moved.

Note that it is possible for the Magnebot to go to positions that aren't "free". The Magnebot's base is a rectangle that is longer on the sides than the front and back. The occupancy grid cell size is defined by the longer axis, so it is possible for the Magnebot to move forward and squeeze into a smaller space. The Magnebot can also push, lift, or otherwise move objects out of its way.

***

## Functions

#### \_\_init\_\_

**`MultiModal()`**

**`MultiModal(port=1071, screen_width=256, screen_height=256)`**

| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| port |  int  | 1071 | The socket port. [Read this](https://github.com/threedworld-mit/tdw/blob/master/Documentation/getting_started.md#command-line-arguments) for more information. |
| screen_width |  int  | 256 | The width of the screen in pixels. |
| screen_height |  int  | 256 | The height of the screen in pixels. |

***

### Scene Setup

_These functions should be sent at the start of the simulation._

#### init_scene

**`self.init_scene(scene, layout)`**

**`self.init_scene(scene, layout, trial=None)`**

**Always call this function before starting a new trial.**

Initialize a scene and a furniture layout, including the target object after it has fallen.
Load the corresponding audio that was generated by the fall (`self.fall`) and position the Magnebot in the same spot as where it was when the object fell.

- For a dictionary of valid scene names and layout indices, see: `MultiModal.SCENE_LAYOUTS`.
- For the total number of trials per scene_layout, see: `MultiModal.TRIALS_PER_SCENE_LAYOUT`
- [These are images of every scene_layout combination](https://github.com/alters-mit/multimodal_challenge/tree/main/doc/images/scene_layouts)


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| scene |  str |  | The name of the scene. |
| layout |  int |  | The layout index. |
| trial |  int  | None | The trial number. |

_Returns:_  An `ActionStatus` (always success).

***

### Movement

_These functions move or turn the Magnebot._

_While moving, the Magnebot might start to tip over (usually because it's holding something heavy). If this happens, the Magnebot will stop moving and drop any objects with mass > 30. You can then prevent the Magnebot from tipping over._

#### turn_by

**`self.turn_by(angle)`**

**`self.turn_by(angle, aligned_at=3, stop_on_collision=True)`**

Turn the Magnebot by an angle.

When turning, the left wheels will turn one way and the right wheels in the opposite way, allowing the Magnebot to turn in place.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `failed_to_turn`
- `tipping`
- `collision`


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| angle |  float |  | The target angle in degrees. Positive value = clockwise turn. |
| aligned_at |  float  | 3 | If the difference between the current angle and the target angle is less than this value, then the action is successful. |
| stop_on_collision |  bool  | True | If True, if the Magnebot collides with the environment or a heavy object it will stop turning. It will also stop turn if the previous action ended in a collision and was a `turn_by()` in the same direction as this action. Usually this should be True; set it to False if you need the Magnebot to move away from a bad position (for example, to reverse direction if it's starting to tip over). |

_Returns:_  An `ActionStatus` indicating if the Magnebot turned by the angle and if not, why.

#### turn_to

**`self.turn_to(target)`**

**`self.turn_to(target, aligned_at=3, stop_on_collision=True)`**

Turn the Magnebot to face a target object or position.

When turning, the left wheels will turn one way and the right wheels in the opposite way, allowing the Magnebot to turn in place.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `failed_to_turn`
- `tipping`
- `collision`


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| target |  Union[int, Dict[str, float] |  | Either the ID of an object or a Vector3 position. |
| aligned_at |  float  | 3 | If the different between the current angle and the target angle is less than this value, then the action is successful. |
| stop_on_collision |  bool  | True | If True, if the Magnebot collides with the environment or a heavy object it will stop turning. Usually this should be True; set it to False if you need the Magnebot to move away from a bad position (for example, to reverse direction if it's starting to tip over). |

_Returns:_  An `ActionStatus` indicating if the Magnebot turned by the angle and if not, why.

#### move_by

**`self.move_by(distance)`**

**`self.move_by(distance, arrived_at=0.3, stop_on_collision=True)`**

Move the Magnebot forward or backward by a given distance.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `failed_to_move`
- `collision`
- `tipping`


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| distance |  float |  | The target distance. If less than zero, the Magnebot will move backwards. |
| arrived_at |  float  | 0.3 | If at any point during the action the difference between the target distance and distance traversed is less than this, then the action is successful. |
| stop_on_collision |  bool  | True | If True, if the Magnebot collides with the environment or a heavy object it will stop moving. Usually this should be True; set it to False if you need the Magnebot to move away from a bad position (for example, to reverse direction if it's starting to tip over). |

_Returns:_  An `ActionStatus` indicating if the Magnebot moved by `distance` and if not, why.

#### move_to

**`self.move_to(target)`**

**`self.move_to(target, arrived_at=0.3, aligned_at=3, stop_on_collision=True)`**

Move the Magnebot to a target object or position.

This is a wrapper function for `turn_to()` followed by `move_by()`.

Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `failed_to_move`
- `collision`
- `failed_to_turn`
- `tipping`


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| target |  Union[int, Dict[str, float] |  | Either the ID of an object or a Vector3 position. |
| arrived_at |  float  | 0.3 | While moving, if at any point during the action the difference between the target distance and distance traversed is less than this, then the action is successful. |
| aligned_at |  float  | 3 | While turning, if the different between the current angle and the target angle is less than this value, then the action is successful. |
| stop_on_collision |  bool  | True | If True, if the Magnebot collides with the environment or a heavy object it will stop moving or turning. Usually this should be True; set it to False if you need the Magnebot to move away from a bad position (for example, to reverse direction if it's starting to tip over). |

_Returns:_  An `ActionStatus` indicating if the Magnebot moved to the target and if not, why.

***

### Torso

_These functions adjust the Magnebot's torso._

_While adjusting the torso, the Magnebot is always "immovable", meaning that its wheels are locked and it isn't possible for its root object to move or rotate._

#### set_torso

**`self.set_torso(position)`**

Slide the Magnebot's torso up or down.

The torso's position will be reset the next time the Magnebot moves or turns.

Possible return values:

- `success`
- `failed_to_bend` (If the torso failed to reach the target position)


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| position |  float |  | The target vertical position of the torso. This is clamped to be within the torso limits (see: `MultiModal.TORSO_LIMITS`). |

_Returns:_  An `ActionStatus` indicating if the torso reached the target position.

***

### Camera

_These commands rotate the Magnebot's camera or add additional camera to the scene. They advance the simulation by exactly 1 frame._

#### guess

**`self.guess(position)`**

**`self.guess(position, radius=0.1, cone_angle=30)`**

Guess where the target object is. For a guess to be correct:

- The target object must be within a sphere defined by `position` and `radius`.
- The target object must be within a cone relative to the camera angle defined by `cone_angle`.

Possible return values:

- `success`
- `ongoing` (The guess was incorrect or the target object is not within the cone.)


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| position |  np.array |  | The center of the sphere of the guess. |
| radius |  float  | 0.1 | The radius of the sphere of the guess. |
| cone_angle |  float  | 30 | The angle of the cone of the guess. |

_Returns:_  `ActionStatus`: `success` if the guess was correct.

***

#### rotate_camera

**`self.rotate_camera()`**

**`self.rotate_camera(roll=0, pitch=0, yaw=0)`**

Rotate the Magnebot's camera by the (roll, pitch, yaw) axes.

Each axis of rotation is constrained (see `Magnebot.CAMERA_RPY_CONSTRAINTS`).

| Axis | Minimum | Maximum |
| --- | --- | --- |
| roll | -55 | 55 |
| pitch | -70 | 70 |
| yaw | -85 | 85 |

See `self.camera_rpy` for the current (roll, pitch, yaw) angles of the camera.


Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`
- `clamped_camera_rotation`


| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| roll |  float  | 0 | The roll angle in degrees. |
| pitch |  float  | 0 | The pitch angle in degrees. |
| yaw |  float  | 0 | The yaw angle in degrees. |

_Returns:_  An `ActionStatus` indicating if the camera rotated fully or if the rotation was clamped..

#### reset_camera

**`self.reset_camera()`**

Reset the rotation of the Magnebot's camera to its default angles.


Possible [return values](https://github.com/alters-mit/magnebot/blob/main/doc/api/action_status.md):

- `success`

_Returns:_  An `ActionStatus` (always `success`).

### Misc.

_These are utility functions that won't advance the simulation by any frames._

#### get_occupancy_position

**`self.get_occupancy_position(i, j)`**

Converts the position `(i, j)` in the occupancy map to `(x, z)` worldspace coordinates.



| Parameter | Type | Default | Description |
| --- | --- | --- | --- |
| i |  int |  | The i coordinate in the occupancy map. |
| j |  int |  | The j coordinate in the occupancy map. |

_Returns:_  Tuple: (x coordinate; z coordinate) of the corresponding worldspace position.

#### get_visible_objects

**`self.get_visible_objects()`**

Get all objects visible to the Magnebot in `self.state` using the id (segmentation color) image.

_Returns:_  A list of IDs of visible objects.

#### end

**`self.end()`**

End the simulation. Terminate the build process.

***

